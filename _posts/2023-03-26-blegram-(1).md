---
layout: post
title: Blegram(1) - 로그인 구현 ( JWT )
author: admin
date: 2023-03-26 21:28:00 +900
lastmod: 2023-03-26 21:28:00 +900
sitemap:
  changefreq: monthly
  priority: 0.5
categories: [Project, blegram]
tags: [blegram, Next.js, TypeScript, JWT, Cookie, login, auth]
---

> 해당 프로젝트는 `Next.js` + `TypeScript`를 기반으로 만드는 인스타그램 클론 개인 프로젝트입니다.<br />
{:.prompt-info}

# 📜 로그인 구현에 사용한 것
1. `bcrypt`: 비밀번호 해싱
2. `jsonwebtoken`: `AccessToken`과 `RefreshToken` 생성에 사용

## 0️⃣ 설치
```bash
npm i bcrypt jsonwebtoken

npm i -D @types/bcrypt @types/jsonwebtoken
```

# 📦 사용하는 유틸리티 함수들
토큰/쿠키 생성과 미들웨어로 사용하는 함수들에 대한 정의와 설명을 작성하겠습니다.<br />

## 0️⃣ 토큰 생성과 검증 함수
인증/리프래쉬 토큰을 생성하는 함수들와 그 토큰들을 검증하는데 사용하는 함수들입니다.<br />

+ `/src/lib/auth.ts`

```ts
import { JsonWebTokenError, sign, verify, type JwtPayload } from "jsonwebtoken";

interface Payload {
  idx: number;
}
interface generateTokenHandler {
  (payload: Payload): string;
}
/**
 * 2023/03/26 - 인증 토큰 발행 ( 유효 기간 1시간 ) - by 1-blue
 * @param payload 토큰의 페이로드
 * @returns 인증 토큰
 */
export const generateAccessToken: generateTokenHandler = (payload) =>
  sign(payload, process.env.ACCESS_SECRET, { expiresIn: "1h" });

/**
 * 2023/03/26 - 리프레쉬 토큰 발행 ( 유효 기간 7일 ) - by 1-blue
 * @param payload 토큰의 페이로드
 * @returns 인증 토큰
 */
export const generateRefreshToken: generateTokenHandler = (payload) =>
  sign(payload, process.env.REFRESH_SECRET, { expiresIn: "7d" });

interface VerifyTokenHandler {
  (type: "access" | "refresh", token: string):
    | {
        payload: JwtPayload;
        status: "SUCCESS";
      }
    | {
        payload: null;
        status: "EXPIRED" | "INVALID";
      };
}
/**
 * 2023/03/26 - 토큰 검증 - by 1-blue
 * @param type 토큰 타입
 * @param token 검증할 토큰
 * @returns 검증 결과
 */
export const verifyToken: VerifyTokenHandler = (type, token) => {
  let secretKey = "";

  switch (type) {
    case "access":
      secretKey = process.env.ACCESS_SECRET;
      break;
    case "refresh":
      secretKey = process.env.REFRESH_SECRET;
      break;
  }

  try {
    const payload = verify(token, secretKey) as JwtPayload;

    return { payload, status: "SUCCESS" };
  } catch (error) {
    // 토큰 관련 에러
    if (error instanceof JsonWebTokenError) {
      // 인증 토큰 만료 ( 인증 토큰 재발급 )
      if (error.message === "jwt expired") {
        return { payload: null, status: "EXPIRED" };
      }
    }

    return { payload: null, status: "INVALID" };
  }
};
```

## 1️⃣ 쿠키 헤더 생성 함수
`Node.js`의 `express`처럼 `res.cookie` 같은 기능을 찾지 못해서 직접 `Header`에 `Set-Cookie`를 등록하기 위해 사용하는 함수입니다.<br />

+ `/src/util/cookie.ts`

```ts
interface generateCookieHandler {
  (name: string, value: string, maxAge: number): string;
}

/**
 * 2023/03/26 - "Set-Cookie" 헤더 생성 - by 1-blue
 * @param name 쿠키 이름
 * @param value 쿠키 값
 * @param maxAge 쿠키 지속 시간
 * @returns 쿠키 헤더 값
 */
export const generateCookie: generateCookieHandler = (name, value, maxAge) => {
  const domain = process.env.NODE_ENV === "development" ? "localhost" : "배포할 경로로 수정";
  const path = "/";
  const sameSite = "Strict";

  return `${name}=${value}; Domain=${domain}; Path=${path}; SameSite=${sameSite}; Max-Age=${maxAge}; HttpOnly; Secure;`;
};
```

## 2️⃣ 미들웨어로 사용하는 HOC
인증만으로 사용하는 것은 아니고 여러 가지 목적으로 사용하는 `Higher-Order-Function`입니다.<br />

+ 사용 목적
  1. 정해진 `HTTP Method`에 대한 응답만 처리
  1. 인증 및 서버에 유저 정보 등록
  1. 인증 토큰 만료 시 재발급
  1. 에러 처리

아래 함수의 문제라고 느껴지는 부분이 크게 두 가지 있습니다.<br />

1. 반복되는 로직이 존재
1. 가독성이 안 좋음
1. 매번 요청 때마다 토큰에 일치하는 유저 정보를 `DB`에서 검색

일단은 마땅한 방법이 떠오르지 않아서 남겨두고 넘어가려고 합니다.<br />
미래에 방법이 생긴다면 수정하고 그에 대한 내용을 작성하겠습니다.<br />

+ `/src/lib/middleware.ts`

```ts
import { prisma } from "@src/prisma";

// lib
import { generateAccessToken, verifyToken } from "@src/lib/auth";

// util
import { clearCookie, generateCookie } from "@src/utils/cookie";

// type
import type { NextApiHandler } from "next";

/** 2023/03/26 - HTTP Methods 타입 - by 1-blue */
type Methods = "GET" | "POST" | "DELETE" | "PATCH";

interface AuthMiddlewareConfig {
  methods: Methods[];
  handler: NextApiHandler;
  isAuth?: boolean;
}
interface WithAuthMiddleware {
  (config: AuthMiddlewareConfig): NextApiHandler;
}

// 2023/03/26 - method에 따른 라우팅을 쉽게 처리해주는 HOF + 접근 권한 확인 - by 1-blue
const withAuthMiddleware: WithAuthMiddleware =
  ({ methods, handler, isAuth = true }) =>
  async (req, res) => {
    // 정해진 메서드를 사용하지 않았다면
    if (!methods.includes(req.method as Methods)) return res.status(405).end();

    // 로그인이 필요한 접근이라면 ( 토큰 검사 후 "req.user"에 로그인한 데이터 넣어주는 로직 )
    if (isAuth) {
      // 쿠키에서 인증/리프래쉬 토큰 갖고오기
      const { bat, brt } = req.cookies;

      // 리프레쉬 토큰이 없는 경우
      if (!brt) {
        return res.status(401).json({
          message: "접근할 권한이 없습니다.\n로그인 후에 접근해주세요.",
        });
      }

      // 리프래쉬 토큰 유효성 검사
      const verifyRefreshToken = verifyToken("refresh", brt);

      // 유효하지 않은 토큰
      if (verifyRefreshToken.status === "INVALID") {
        // 유효하지 않은 토큰 지우기
        res.setHeader("Set-Cookie", [
          clearCookie("brt", brt),
          clearCookie("bat", bat),
        ]);

        return res.status(401).json({
          message: "유효하지 않은 토큰입니다.\n다시 로그인해주세요.",
        });
      }
      // 리프래쉬 토큰 유효기간 만료
      if (verifyRefreshToken.status === "EXPIRED") {
        // 만료된 토큰 지우기
        res.setHeader("Set-Cookie", [
          clearCookie("brt", brt),
          clearCookie("bat", bat),
        ]);

        return res.status(401).json({
          message: "만료된 토큰입니다.\n다시 로그인해주세요.",
        });
      }
      // 안전한 타입을 위해 검사
      if (verifyRefreshToken.status !== "SUCCESS") {
        return res.status(500).json({
          message: "서버측 문제입니다.\n잠시후에 다시 시도해주세요!",
        });
      }

      // 인증 토큰이 없는 경우
      if (!bat) {
        // 인증 토큰 생성
        const accessToken = generateAccessToken({
          idx: verifyRefreshToken.payload.idx,
        });

        // 인증 토큰 쿠키로 등록
        res.setHeader(
          "Set-Cookie",
          generateCookie("bat", accessToken, 1000 * 60 * 60)
        );

        // 리다이렉트
        return res.status(302).redirect(req.url || "/");
      }

      // 인증 토큰이 있는 경우
      // 인증 토큰 유효성 검사
      const verifyAccessToken = verifyToken("access", bat);

      // 유효하지 않은 인증 토큰
      if (verifyAccessToken.status === "INVALID") {
        // 유효하지 않은 토큰 지우기
        res.setHeader("Set-Cookie", clearCookie("bat", bat));

        return res.status(401).json({
          message: "유효하지 않은 토큰입니다.\n다시 로그인해주세요.",
        });
      }
      // 인증 토큰 유효기간 만료 ( 인증 토큰 재발급 )
      if (verifyAccessToken.status === "EXPIRED") {
        // 인증 토큰 생성
        const accessToken = generateAccessToken({
          idx: verifyRefreshToken.payload.idx,
        });

        // 인증 토큰 쿠키로 등록
        res.setHeader(
          "Set-Cookie",
          generateCookie("bat", accessToken, 1000 * 60 * 60)
        );

        // 리다이렉트
        return res.status(302).redirect(req.url || "/");
      }
      // 안전한 타입을 위해 검사
      if (verifyRefreshToken.status !== "SUCCESS") {
        return res.status(500).json({
          message: "서버측 문제입니다.\n잠시후에 다시 시도해주세요!",
        });
      }

      try {
        // 토큰에 일치하는 유저 검색
        const exUser = await prisma.user.findUnique({
          where: { idx: verifyRefreshToken.payload.idx },
        });

        // 존재하지 않는 유저 ( 인증 토큰을 갖고 회원 탈퇴한 경우 )
        if (!exUser)
          return res.status(404).json({
            message: "존재하지 않는 유저입니다.\n다시 로그인해주세요.",
          });

        // 비밀번호 제외하기
        const { password, ...user } = exUser;

        // 응답 객체에 유저 정보 등록
        Object.defineProperty(req, "user", {
          value: user,
          writable: false,
          configurable: false,
        });
      } catch (error) {
        // 알 수 없는 서버측의 에러
        console.error("middleware token error >> ", error);
        return res
          .status(500)
          .json({ message: "서버측 문제입니다.\n잠시후에 다시 시도해주세요!" });
      }
    }

    try {
      await handler(req, res);
    } catch (error) {
      console.error("middleware server error >> ", error);

      return res
        .status(500)
        .json({ message: "서버측 문제입니다.\n잠시후에 다시 시도해주세요!" });
    }
  };

export default withAuthMiddleware;
```

# 🎞️ 로그인 로직의 흐름
일단 전체적인 흐름에 대해 간략하게 설명하고 이후에 코드를 보면서 더 자세하게 설명하겠습니다.<br />

1. 브라우저에서 `id`와 `password`를 서버로 전달
1. 서버에서 `id`와 `password`에 해당하는 유저 있는지 확인 ( `prisma`, `bcrypt` )
1. 유저가 존재한다면 `JWT`로 만들어진 `AccessToken`과 `RefreshToken` 생성 후 쿠키에 동봉
1. 유저 정보를 요청하는 엔드포인트로 리다이렉트
1. 엑세스 토큰을 이용해서 해당 유저 정보를 클라이언트로 응답
1. 이후에 접근할 때마다 미들웨어처럼 동작하는 래퍼 함수를 이용해서 유저 데이터 찾기
1. 엑세스 토큰 만료 시 재생성 / 리프래쉬 토큰 만료 시 모든 토큰 제거

## 0️⃣ 정보 확인과 토큰 생성 및 리다이렉트
`prisma`와 `bcrypt`를 사용해서 클라이언트에게 받은 정보에 해당하는 유저가 있는지 먼저 확인합니다.<br />
해당 유저가 없다면 `403`으로 응답하고 끝냅니다.<br />

만약 유저가 존재한다면 해당 유저에게 부여할 `AccessToken`과 `RefreshToken`을 생성하고 쿠키에 넣습니다.<br />
쿠키를 동봉할 때는 `Header`의 `Set-Cookie`에 배열 형태로 넣어주면 두 개의 쿠키가 동시에 들어가게 됩니다.<br />

유저 정보는 다른 엔드 포인트를 통해서 브라우저로 전달하기 때문에 리다이렉트해줍니다.<br />

+ `/src/pages/api/login.ts`

```ts
interface LogInBody {
  id: string;
  password: string;
}

const handler: NextApiHandler = async (req, res) => {
  try {
    // 로그인
    if (req.method === "POST") {
      const { id, password } = req.body as LogInBody;

      // 아이디가 일치하는 유저 있는지 검색
      const exUser = await prisma.user.findUnique({
        where: { id },
        select: { idx: true, password: true },
      });

      // 아이디에 해당하는 유저가 존재하지 않음
      if (!exUser)
        return res.status(403).json({ message: "존재하는 유저가 없습니다." });

      // 비밀번호 일치 여부 확인
      const isValidated = await bcrypt.compare(password, exUser.password);
      // 비밀번호 불일치
      if (!isValidated) {
        return res
          .status(403)
          .json({ message: "비밀번호가 일치하지 않습니다." });
      }

      // 인증/리프레쉬 토큰 생성
      const accessToken = generateAccessToken({ idx: exUser.idx });
      const refreshToken = generateRefreshToken({ idx: exUser.idx });

      // 인증/리프래쉬 토큰 쿠키로 등록
      res.setHeader("Set-Cookie", [
        generateCookie("bat", accessToken, 1000 * 60 * 60),
        generateCookie("brt", refreshToken, 1000 * 60 * 60 * 24 * 7),
      ]);

      res.status(302).redirect("/api/me");
    }
  } catch (error) {
    console.error("/api/login error >> ", error);

    return res
      .status(500)
      .json({ message: "서버측 문제입니다.\n잠시후에 다시 시도해주세요!" });
  }
};
```

## 1️⃣ 로그인한 유저 정보 응답
`/api/me`라는 엔드 포인트를 이용해서 로그인한 유저의 정보를 얻을 수 있습니다.<br />

여기서 중요한 점은 위에서 작성한 [`withAuthMiddleware()`](/posts/blegram-(1)/#2%EF%B8%8F⃣-미들웨어로-사용하는-hoc)를 통해서 로그인된 유저인지, 검증된 토큰인지 확인하는 로직을 처리한다는 점입니다.<br />
아래처럼 엔드 포인트의 라우터를 실행하기 전에 `withAuthMiddleware()`를 먼저 실행합니다.<br />
그리고 `isAuth`를 통해서 인증된 유저만 접근이 가능한 부분인지 확인합니다.<br />

작성된 로직을 통해서 인증 토큰이 만료되었다면 재발급하고, 리프래쉬 토큰이 만료되었다면 토큰을 제거합니다.<br />
그리고 토큰이 유효하다면 `req.user`에 현재 로그인한 유저의 데이터를 넣어줍니다.<br />
따라서 다른 라우터에서는 안전하게 로그인한 유저의 정보를 사용할 수 있습니다.<br />

+ `/src/pages/api/me.ts`

```ts
// lib
import withAuthMiddleware from "@src/lib/middleware";

// type
import type { NextApiHandler } from "next";

const handler: NextApiHandler = async (req, res) => {
  console.log(req.user); // "password"를 제외한 로그인한 유저의 데이터

  // ... 나머지 생략

  return res.json({ message: "일단 OK" });
};

export default withAuthMiddleware({
  methods: ["GET"],
  handler,
  isAuth: true,
});
```

## 2️⃣ 타입 재정의
단, 위처럼 사용하는 경우 `req.user`라는 속성을 `TypeScript`에서 알지 못하기 때문에 타입을 재정의해줘야합니다.<br />

`(1)`처럼 사용하고 싶은데 적용이 안돼서 `NextApiRequest`의 부모인 `IncomingMessage`에 적용할 타입을 명시했습니다.<br />

+ `/src/@types/next.d.ts`

```ts
import type { User } from "@prisma/client";

/** "NextApiRequest" 재정의 ( TODO: 정확히는 모르겠으나 "IncomingMessage"를 상속받음 ) */
declare module "http" {
  interface IncomingMessage {
    user?: Omit<User, "password">;
  }
}

// (1) FIXME: 아래처럼 사용하고 싶은데 안 되는 이유를 모르겠음
// interface NextApiRequest {
//   user: Omit<User, "password">;
// }
```

# 🃏 삽질에 대한 기록
## 0️⃣ Next.js 13 사용
`Next.js 13`에서는 `/app`을 사용하고 `/app/api/route.ts`라는 약속으로 엔드 포인트를 만들어냅니다.<br />

아래와 같이 함수 이름으로 `HTTP Method`를 구분하고 `request`, `response`와 같은 것도 사용하는 방법이 전혀 다릅니다.<br />
사용 방법이 다른 것은 공부하고 익숙해지면 되는데 아직 구현이 덜 된 건지 제가 방법을 못 찾는 것인지 모르겠지만 쿠키를 여러 개 보내는 방법이 없습니다.<br />
그리고 미들웨어를 설명하는 문서도 비어있어서 어떻게 해야할지 모르겠어서 하루종일 찾고 적고 수정하고 하다가 지쳐서 포기했습니다... 😢<br />

쿠키를 여러 개 못 만드는 것은 일단 리다이렉트를 이용해서 임시로 처리했는데, 미들웨어를 사용하는 방법을 몰라서 로그인할 때마다 반복되는 코드를 계속 넣는 것이 너무 힘들고 비효율적일 것 같아서 그냥 이전 버전 방식으로 다시 작성했습니다.<br />

( 프론트 부분도 13 이전 버전의 방식으로 돌아갈까 고민하고 있는 중입니다... 🥲 )<br />

```ts
export const POST = async (req: NextRequest) => {
  const body = await req.json();

  return NextResponse.json(
    { message: "대충 성공했다는 메시지" },
    {
      status: 200, 
      headers: { "Set-Cookie": "쿠키이름=쿠키값;" },
    }
  );
};
```

# 📮 레퍼런스
1. [1-blue - JWT](/posts/Token){:target="_blank"}
1. [1-blue - Cookie](/posts/Cookie){:target="_blank"}