---
layout: post
title: 이펙티브 타입스크립트 5장 ( Item 38 ~ 40 )
author: admin
date: 2023-02-11 16:50:00 +900
lastmod: 2023-02-11 16:50:00 +900
sitemap:
  changefreq: monthly
  priority: 0.5
categories: [Study, 이펙티브 타입스크립트]
tags: [이펙티브 타입스크립트]
image:
  path: https://insightbookblog.files.wordpress.com/2021/06/ec9db4ed8e99ed8bb0ebb88c-ed8380ec9e85ec8aa4ed81aceba6bded8ab8-ec9e85ecb2b4ed919ceca780.jpg?w=640
  width: 400
  height: 250
  alt: 이펙티브 타입스크립트 교재 이미지
---

> 해당 포스트는 `이펙티브 타입스크립트` 5장을 읽고 정리한 포스트입니다.<br />책의 모든 내용을 작성하는 것이 아닌 주관적인 기준에 따라 필요한 정보만 정리했습니다.<br />
{: .prompt-info}

📖 5장 any 다루기

# 📌 Item 38 ( any 타입은 가능한 한 좁은 범위에서만 사용하기 )
`any`는 사용하지 않거나 가능한 좁은 범위로 사용하는 것이 좋습니다.<br />

`any`는 타입 체커의 동작을 억제시키기 때문에 정상적으로 타입을 체크하지 않아서 `TypeScript`의 사용하는 이유중 하나인 런타임 이전에 정적으로 타입을 체크하는 기능을 활용할 수 없게 됩니다.<br />
( 즉, 런타임에 발생할 오류를 미리 확인할 수 없게 됩니다. )<br/>

## 0️⃣ 함수에서 any 타입 좁게 사용하기
함수에서 `any`를 사용한다면 최대한 좁게 그리고 반환 타입에는 `any`를 사용하지 않도록 해야합니다.<br />
`any`를 반환하면 외부의 코드에 `any`가 퍼지기 때문에 타입 체커의 이점을 활용할 수 없습니다.<br />

```ts
type Foo = { name: string };
type Bar = { age: number };

declare function expressionReturnFoo(): Foo;
declare function processBar(b: Bar): void;

const f1 = () => {
  const x = expressionReturnFoo();

  processBar(x); // Error: 'Foo' 형식의 인수는 'Bar' 형식의 매개 변수에 할당될 수 없습니다.

  return x;
};

const f2 = () => {
  const x: any = expressionReturnFoo();

  processBar(x);

  // any 반환 ( 위험한 행동 )
  return x;
};

const f3 = () => {
  const x = expressionReturnFoo();

  processBar(x as any);

  return x;
};

const f4 = () => {
  const x = expressionReturnFoo();

  // @ts-ignore
  processBar(x);

  return x;
};

const g = () => {
  const foo2 = f2();
  // any를 반환하기 때문에 외부에도 영향을 끼쳐서 타입 체커가 제대로 동작하지 않음
  foo2.fooMethod(); // 에러가 발생되지 않음

  const foo3 = f3();
  // 내부적으로만 any를 사용하기 때문에 외부에 영향을 끼치지 않음
  foo3.fooMethod(); // Error: 'Foo' 형식에 'fooMethod' 속성이 없습니다.
};
```

## 1️⃣ 객체에서 any 타입 좁게 사용하기
객체에서 `any`를 사용할 때도 전체에 사용하기 보다는 필요한 부분에만 사용하는 것이 좋습니다.<br />
잘못 사용하면 객체 전체의 타입 체크를 무시하게 됩니다.<br />

```ts
type Foo = { name: string };
type Config = {
  a: number;
  b: number;
  c: { key: Foo };
};

const config1: Config = {
  a: 1,
  b: 2,
  c: {
    key: 123, // Error: number' 형식은 'Foo' 형식에 할당할 수 없습니다.
  },
};

const config2: Config = {
  // a, b의 타입 체크를 하지 않음
  a: true,
  b: "문자",
  c: {
    key: 123, // 에러는 사라졌지만 모든 타입 체크를 무시함
  },
} as any;

const config3: Config = {
  // a, b의 타입 체크는 유효함
  a: 1,
  b: 2,
  c: {
    key: 123 as any,
  },
};
```

## 🎊 Item 38 결론
1. `any`의 사용 범위는 최소한으로 좁히기
2. 반환 타입에 절대 `any`사용하지 않기
3. 강제로 타입 오류를 제거해야 하는 경우라면 `// @ts-ignore` 사용하기

# 📌 Item 39 ( any를 구체적으로 변형해서 사용하기 )
`any`는 그 어떤 타입도 받을 수 있기 때문에 만약 `any`를 사용한다고 하더라도 최대한 구체적으로 표현하는 것이 좋습니다.<br />

## 0️⃣ 조금이라도 더 구체적인 any
길이를 구하는 목적이라면 `(1)`보다는 `(2)`가 더 구체적입니다.<br />
( `(2)`의 반환 값은 `number`로 추론이 됩니다. )<br />

그리고 `(3)`으로 사용하면 더 구체적이라고 합니다.<br />
그냥 제일 좋은 방법은 `any`를 사용하지 않는 것이 좋지 않을까 합니다.<br />

만약 필요하다면 `unknown`을 사용하는 것이 좋은 것 같습니다.<br />
( `unknown`은 모든 값을 받을 수 있지만 사용하는 경우 타입 에러를 발생시킴 )<br />
TODO: `unknown` 경로 추가

```ts
// (1) (arr: any) => any
const getLengthBad = (arr: any) => arr.length;

// (2) (arr: any[]) => number
const getLength = (arr: any[]) => arr.length;

// (3) 아래 방법이 조금이라도 더 구체적으로 사용하는 방법이라고 합니다.
type F0 = () => any;
type F1 = (arg: any) => any;
type F2 = (...args: any[]) => any; // "Function"타입과 같은 타입
// 추측이긴 한데 "function"타입이 아닌 이유는 "function" 키워드와 겹쳐서 그런 것 같음
// "String"래퍼 객체 -> "string"타입과 같은 느낌
```

## 1️⃣ 객체를 any처럼 사용하기
어떤 객체라도 받는 타입을 정하기 위해서는 `object`나 `index signature`를 사용해야 합니다. ( 물론 `any`도 가능하긴 합니다. )<br />

`object`타입은 열거만 가능하고 프로퍼티에 접근하는 것이 불가능합니다.<br />
하지만 `index signature`는 모두 가능합니다.<br />
( 그래도 `(4)`를 통해서 확인했는데 접근이 불가능 한것은 조금 이상하게 느껴지네요.. 🥲 )<br />

```ts
// "any" 타입 사용
const hasTwelveLetterKey0 = (obj: any) => {
  for (const key in obj) {
    if (key.length === 12) return true;

    // 정상 동작
    console.log(obj[key]);
  }

  return false;
};

// "object" 타입 사용
const hasTwelveLetterKey1 = (obj: object) => {
  // (4)
  for (const key in obj) {
    if (key.length === 12) return true;

    // "object" 타입은 나열만 가능 ( 이상하게 "in"연산자로 확인해도 접근 불가능 )
    console.log(obj[key]); // Error: 'string' 형식의 식을 '{}' 인덱스 형식에 사용할 수 없으므로 요소에 암시적으로 'any' 형식이 있습니다.
  }

  return false;
};

// 인덱스 시그니처 사용
const hasTwelveLetterKey2 = (obj: { [key: string]: any }) => {
  for (const key in obj) {
    if (key.length === 12) return true;

    // 정상 동작
    console.log(obj[key]);
  }

  return false;
};
```

## 🎊 Item 39 결론
1. 반드시 `any`가 필요한지 다시 확인하기
2. 만약 `any`를 사용하게 되면 최대한 구체적인 형태로 사용하기

# 📌 Item 40 ( 함수 안으로 타입 단언문 감추기 )
## 0️⃣ 함수 내부에서만 확실하게 타입 단언하기
아래 예시는 객체가 같은 지 비교하는 함수입니다.<br />

`(1)`에서 해당 객체에 `key`가 존재하는지 확인했지만 `b[key]`를 사용하면 타입 에러가 발생합니다. ( `TypeScript`의 문제인 것 같음 )<br />
따라서 앞의 코드로 오류가 날 수 없는 코드임을 확신했기 때문에 `(b as any)[key]`를 사용했습니다.<br />
( `any`를 사용하는 타입 단언문의 좋은 예시인 것 같습니다. )<br />

```ts
const shallowEqual = <T extends object>(a: T, b: T): boolean => {
  for (const [key, value] of Object.entries(a)) {
    // (1) "b[key]"처럼 사용하면 타입 오류 발생 ( 'string' 형식의 식을 '{}' 인덱스 형식에 사용할 수 없으므로 요소에 암시적으로 'any' 형식이 있습니다. )
    if (!(key in b) || value !== (b as any)[key]) {
      return false;
    }
  }

  return Object.keys(a).length === Object.keys(b).length;
};
```

## 1️⃣ 함수 내부에서 any 사용과 타입 단언하기
아래 코드는 마지막 호출을 캐싱하는 기능을 하는 함수입니다.<br />

`(2)`에서는 강제적으로 타입을 변환했는데 그 이유가 타입 체커가 `(3)`에서 반환하는 함수와 `T`타입의 관계를 파악하지 못하기 때문입니다.<br />
저희가 코드를 읽으면 어차피 인자로 받은 함수를 호출한 리턴 값을 반환하는 함수를 반환하기 때문에 `T`를 반환하는 것에 캐싱 기능을 추가한 것이라고 판단할 수 있지만 타입 체커가 판단하지 못하기 때문에 직접적으로 `(3)`의 반환 함수가 `T`와 같은 타입이라고 명시했습니다.<br />

그리고 `cacheLast()` 내부적으로 `any`를 많이 사용했습니다.<br />
왜냐하면 어떤 함수가 인자로 들어올지 예측할 수 없고 그 함수가 어떤 값을 반환하고 우리가 어떤 값을 캐싱해야 할지 모든 경우를 예측해서 작성할 수 없어서라고 생각합니다.<br />
따라서 내부적으로 `any`를 이용했지만, 중요한 것은 외부에 `any`가 나가지 않았기 때문에 내부 동작에만 문제가 없다면 아래 코드는 문제가 발생하지 않는 코드라고 생각했습니다.<br />

아래 예시는 함수 내부에서 `any`를 활용하고 타입 단언문을 사용하는 것의 좋은 예시인 것 같습니다.<br />

```ts
const cacheLast = <T extends Function>(fn: T): T => {
  let lastArgs: any[] | null = null;
  let lastResult: any;

  // (3)
  return ((...args: any[]) => {
    // 이전 실행과 동일하지 않다면 함수 실행
    if (!lastArgs || !shallowEqual(lastArgs, args)) {
      lastResult = fn(...args);
      lastArgs = args;
    }
    // 그게 아니면 이전의 값을 그대로 사용

    return lastResult;
  }) as unknown as T;
  // (2) "as unknown as T"
};
```

## 🎊 Item 40 결론
1. 타입 단언문을 불가피하게 사용해야 하는 경우에는 함수 내부에 숨겨서 사용하기

# 📮 레퍼런스
1. « 이펙티브 타입스크립트 5장 » ( 댄 밴더캄 지음, 장원호 옮김, 인사이트, 2021 )