---
layout: post
title: 이펙티브 타입스크립트 4장 ( Item 28 ~ 33 )
author: admin
date: 2023-01-30 08:34:00 +900
lastmod: 2023-02-08 09:12:00 +900
sitemap:
  changefreq: monthly
  priority: 0.5
categories: [Study, 이펙티브 타입스크립트]
tags: [이펙티브 타입스크립트]
image:
  path: https://insightbookblog.files.wordpress.com/2021/06/ec9db4ed8e99ed8bb0ebb88c-ed8380ec9e85ec8aa4ed81aceba6bded8ab8-ec9e85ecb2b4ed919ceca780.jpg?w=640
  width: 400
  height: 250
  alt: 이펙티브 타입스크립트 교재 이미지
---

> 해당 포스트는 `이펙티브 타입스크립트` 4장을 읽고 정리한 포스트입니다.<br />책의 모든 내용을 작성하는 것이 아닌 주관적인 기준에 따라 필요한 정보만 정리했습니다.<br />
{: .prompt-info}

📖 4장 타입 설계

# 📌 Item 28 ( 유효한 상태만 표현하는 타입을 지향하기 )

## 0️⃣ 유효한 상태와 무효한 상태를 같이 처리하는 타입
웹 애플리케이션을 만든다고 가정하고 아래 타입은 웹 애플리케이션의 페이지 로딩에 대한 타입입니다.<br />

```ts
// (1)
type State = {
  pageText: string;
  isLoading: boolean;
  error: string;
};

const changePage = async (state: State, newPage: string) => {
  state.isLoading = true;

  try {
    const response = await fetch(newPage);

    if (!response.ok) {
      throw new Error("failed fetch");
    }

    const text = await response.text();
    state.pageText = text;
  } catch (error) {
    state.error = "" + error;
  } finally {
    state.isLoading = false;
  }
};
```

`(1)`의 타입은 몇 가지 문제점이 있습니다.<br />
1. `error`가 발생한 이후 다음 실행부터는 페이지 로딩 시 에러를 보여줌 ( 즉, `error` 초기화 로직 없음 )
2. 페이지를 이동하던 중에 다른 페이지로 이동하면 결과가 이상할 수 있음

## 1️⃣ 유효한 상태와 무효한 상태를 나눠서 처리하는 타입
[태그된 유니온](/posts/이펙티브-타입스크립트-3장/#2%EF%B8%8F⃣-태그구별된-유니온){:target="_blank"}을 이용하면 상태에 맞는 값을 명시적으로 가질 수 있습니다.<br />
이전 예시는 로딩중에도 에러나 성공의 값을 가질 수 있는 반면 태그된 유니온을 사용하면 로딩중에만 갖는 값, 성공에만 갖는 값, 실패에만 갖는 값을 명확하게 나눌 수 있습니다.<br />

```ts
type RequestPending = {
  state: "pending";
};
type RequestSuccess = {
  state: "success";
  pageText: string;
};
type RequestFailure = {
  state: "failure";
  error: string;
};
type RequestState = RequestPending | RequestSuccess | RequestFailure;
type State = {
  currentPage: string;
  request: { [page: string]: RequestState };
};

const chagePage = async (state: State, newPage: string) => {
  state.currentPage = newPage;
  state.request[newPage] = { state: "pending" };

  try {
    const response = await fetch(newPage);

    if (!response.ok) {
      throw new Error("failed fetch");
    }

    const pageText = await response.text();
    state.request[newPage] = { state: "success", pageText };
  } catch (error) {
    state.request[newPage] = { state: "failure", error: "" + error };
  }
};
```

만약 사용자가 페이지 로딩중에 다른 페이지로 이동하더라도 `state.currentPage`가 마지막으로 이동한 페이지의 값을 가리키기 때문에 어떤 페이지가 렌더링될지에 대한 모호함도 없습니다.<br />

## 🎊 Item 28 결론
1. 유효한 상태와 무효한 상태를 둘 다 표현하는 타입 지양하기 ( 코드는 짧을 수 있으나 혼란을 초래할 가능성이 높음 )
2. 유요한 상태와 무효한 상태에 대한 타입을 나눠서 작성하기 ( 코드가 길어도 명확한 코드 )

# 📌 Item 29 ( 사용할 때는 너그럽게, 생성할 때는 엄격하게 )
카메라 위치를 지정하고 경계 박스의 뷰포트를 계산하는 방법에 대한 코드 예시입니다.<br />
( 교재의 예시를 그대로 가져와 사용했습니다. )<br />

## 0️⃣ 매개변수의 타입은 넓게, 반환 타입도 넓게
대부분의 타입을 옵셔널로 만들어서 유연하게 동작하도록 만들었습니다.<br />

```ts
declare function calculateBoundingBox(
  f: Feature
): [number, number, number, number];
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
declare function setCamera(camera: CameraOptions): void;

type Feature = any;
type CameraOptions = {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
};
type LngLat =
  | { lng: number; lat: number }
  | { lon: number; lat: number }
  | [number, number];
type LngLatBounds =
  | { northeast: LngLat; southwest: LngLat }
  | [LngLat, LngLat]
  | [number, number, number, number];

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  // (1) Error: 'LngLat | undefined' 형식에 'lat' 속성이 없습니다.
  const { center: { lat, lng }, zoom } = camera;
  zoom; // number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

반환 타입도 유연하게 선언해줬기 때문에 `(1)`에서 타입을 확정지을 수 없게 됩니다.<br />

코드가 조금 길어지고 복잡해보일 수 있어도 엄격한 타입과 유연한 타입을 만드는 것이 좋습니다.<br />
( 매개변수를 위한 타입 / 반환 값을 위한 타입 )<br />

## 1️⃣ 매개변수의 타입은 넓게, 반환 타입은 좁게
가능하다면 제목처럼 매개변수의 타입은 알아서, 반환 타입은 좁게하는 것이 좋습니다.<br />
반환 타입을 넓게 잡아버리면 `(1)`과 같은 문제가 발생해서 받는 쪽에서 분기를 나눠서 타입이 어떤지 구분해야 하는 불편함이 발생합니다.<br />

```ts
declare function calculateBoundingBox(
  f: Feature
): [number, number, number, number];
// (3)
declare function viewportForBounds(bounds: LngLatBounds): Camera;
declare function setCamera(camera: CameraOptions): void;

type Feature = any;
// (2)
type LngLat = { lng: number; lat: number }
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

// (2)
type Camera = { center: LngLat; zoom: number; bearing: number; pitch: number }
type CameraOptions = Omit<Partial<Camera>, "center"> & {
  center?: LngLatLike;
};
type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  // (4)
  const { center: { lat, lng }, zoom } = camera;
  zoom; // number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

`(2)`에서 기본 타입을 만들고 가능하다면 유틸리티를 사용하고 아니라면 직접적으로 옵셔널 타입을 따로 만들었습니다.<br />
타입의 정의가 늘어나는 단점이 있지만 타입은 읽기 어렵지 않기 때문에 타입이 늘어나는 것은 크게 문제가 되지 않습니다.<br />

`(3)`에서는 확실한 타입을 리턴하게 해서 `(4)`에서 받아서 그대로 사용할 수 있게 됩니다.<br />

## 🎊 Item 29 결론
1. 매개변수 타입은 넓게, 반환 타입은 좁게
2. 매개변수와 반환 타입을 위해 기본 타입을 만들고 가공해서 유연한 타입을 만드는 것이 좋음 ( 위 예시 `(2)` )

# 📌 Item 30 ( 문서에 타입 정보를 쓰지 않기 )
## 0️⃣ 주석으로 타입에 대한 설명 쓰지 않기
아래 코드는 함수에 대한 내용을 주석을 이용해서 설명한 코드입니다.<br />

```ts
/**
 * (1) 배경색을 문자열로 반환
 * (2) 0 | 1개의 매개변수를 받음
 * (3) 매개변수가 없으면 표준 배경색을 반환
 * (4) 매개변수가 있으면 특정 페이지의 배경색을 반환
 */
const getBackground = (page?: string) => page === "login" ? { r: 100, g: 100, b: 100 } : { r: 0, g: 0, b: 0 };
```

+ 문제점
  1. 잘못된 내용
  2. 필요 없는 내용

`(1)`, `(2)` 같은 내용은 함수 시그니처를 통해서 충분히 해석할 수 있는 내용인데도 주석으로 설명을 붙였습니다.<br />
지금은 상관 없을 수 있으나 만약 `getBackground()`가 수정될 경우 주석을 수동으로 바꿔주는 행동을 잊을 수 있습니다.<br />
그렇기 때문에 코드로 충분히 해석 가능한 내용을 주석으로 작성할 필요는 없습니다.<br />

`(3)`, `(4)` 또한 코드로 충분히 해석이 가능하기 때문에 주석을 작성하는 것은 좋지 않습니다.<br />
혹시 함수, 매개변수, 리턴 값에 대한 설명이 필요하다면 [JSDoc](/posts/JSDoc/){:target="_blank"}을 이용하는 것이 좋습니다.<br />

## 1️⃣ 변수명 규칙
변수명에는 정해진 규칙이 있습니다.<br />
여기서는 그런 정해진 규칙외에 사람과 사람의 소통을 위한 규칙을 설명하고자 합니다.<br />

```ts
// (5)
const ageNum = 10;

// (6)
const timeMs = 1_000;
const temperatureC = 36.5;
```

`(5)`처럼 변수의 타입에 대한 내용을 변수명으로 붙이는 방법은 좋지 않습니다.<br />
( `typescript`라서 명확하게 어떤 타입인지 확인할 수 있기 때문이죠. )<br />

`(6)`처럼 단위같이 작성하지 않으면 확실하게 알 수 없는 것은 붙이면 좋습니다.<br />
( `time`이라고하면 작성된 값을 보고 `ms`라고 추측을 하겠지만, 명확하지 않습니다. )<br />

## 🎊 Item 30 결론
1. 주석과 변수명에 타입 정보를 넣지 않기 ( 모순이 발생할 수 있음 )
2. 타입이 명확하지 않다면 변수명에 단위 정보를 포함하는 것은 좋음

# 📌 Item 31 ( 타입 주변에 null값 배치하기 )

## 0️⃣ 전체에 명확한 타입 지정하기
아래 예시는 최댓값과 최솟값을 구하는 두 가지 예시가 있습니다.<br />

`extent1()`는 부분적으로만(`(1)`) / `extent2()`는 전체적으로(`(3)`) `falsy`값을 체크했습니다.<br />
그래서 `(2)`와 `(4)` 같은 결과가 나왔습니다.<br />

`(2)`의 경우는 배열에 진짜와 가짜의 값이 섞여있기 때문에 사용하기 매우 불편합니다.<br />
배열을 순회할 때마다 값이 존재하는지 여부를 체크하고 확정된 상태에서만 사용할 수 있습니다.<br />
하지만 `(4)`는 배열 자체가 있거나 없거나이기 때문에 배열만 존재하는지 판단하면 내부의 값은 무조건 존재한다고 확정할 수 있습니다.<br />

( `A`가 `B`로부터 비롯된 값이라면 `A`가 `null`이 될 수 있다면 `B`도 `null`이 될 수 있고,<br /> `A`가 `null`이 될 수 없다면 `B`도 `null`이 될 수 없음 )<br />

```ts
const extent1 = (numbers: number[]) => {
  let min;
  let max;

  for (const number of numbers) {
    // (1) "min"만 "falsy" 값 제외 ( "max"에 대한 힌트는 타입 체커에게 주지 않음 )
    if (!min) {
      min = number;
      max = number;
    } else {
      min = Math.min(min, number);
      // (2) max: number | undefined
      max = Math.max(number, max);
    }
  }

  // (2) (number | undefined)[]
  return [min, max];
};

const extent2 = (numbers: number[]) => {
  let result: [number, number] | null = null;

  for (const number of numbers) {
    // (3) 전체를 제외 혹은 전체에 값 할당
    if (!result) {
      result = [number, number];
    } else {
      result = [Math.min(result[0], number), Math.max(result[1], number)];
    }
  }

  // (4) [number, number] | null
  return result;
};
```

## 1️⃣ 클래스에는 확실한 값만 작성하기
아래처럼 클래스를 작성하면 클래스의 필드 값들인 `user`와 `posts`에 `null`인 경우가 존재하고 그 상황에 값을 사용할 수 있습니다.<br />
즉, `(5)`를 통해서 초기화해줬지만 그 전에 이미 `user`라는 인스턴스는 존재하고, 인스턴스의 내부에 값들이 존재하지 않아도 마음대로 사용할 수 있죠.<br />

```ts
type UserInfo = { name: string };
type Post = {};

declare function fetchUser(url: string): Promise<UserInfo>;
declare function fetchPosts(url: string): Promise<Post[]>;

class UserPosts {
  private user: UserInfo | null;
  private posts: Post[] | null;

  constructor() {
    this.user = null;
    this.posts = null;
  }

  async init(userId: string) {
    return Promise.all([
      async () => (this.user = await fetchUser("...특정 유저의 패치하는 URL")),
      async () => (this.posts = await fetchPosts("...게시글들을 패치하는 URL")),
    ]);
  }

  getName() {
    // (6)
    return this.user?.name;
  }
}

const user = new UserPosts();
// (5) 메서드를 실행하는 동안은 "user", "posts"가 존재하지 않음 즉, 불확실한 값
user.init("1");

// (7)
user.getName(); // undefined or 패치한 유저의 이름 ( 어떤 값인지 확정지을 수 없음 )
```

아래 예시의 `(8)`처럼 만들면 데이터가 존재하는 상황에서 인스턴스를 만들 수 있습니다.<br />
따라서 클래스를 사용할 때(`(9)`) 값의 존재에 대한 모호함이 사라져서 명확하게 사용할 수 있게 됩니다.<br />

```ts
type UserInfo = { name: string };
type Post = {};

declare function fetchUser(url: string): Promise<UserInfo>;
declare function fetchPosts(url: string): Promise<Post[]>;

class UserPosts {
  private user: UserInfo;
  private posts: Post[];

  constructor(user: UserInfo, posts: Post[]) {
    this.user = user;
    this.posts = posts;
  }

  // 정적 메서드
  static async init(userId: string) {
    return Promise.all([
      fetchUser("...특정 유저의 패치하는 URL"),
      fetchPosts("...게시글들을 패치하는 URL"),
    ]);
  }

  getName() {
    return this.user.name;
  }
}

(async () => {
  // (8) 인스턴스 생성 전에 값부터 얻기
  const [myUser, myPosts] = await UserPosts.init("1");
  const user = new UserPosts(myUser, myPosts);

  // (9)
  user.getName();
})();
```

> TMI: 이전에 `TS`로 간단한 [마리오 웹 게임](/categories/mario/){:target="_blank"}을 만들었는데 그때는 이런 내용을 몰라서 가끔 `null`이 포함된 필드가 있습니다... ( 나중에 수정해야겠네요... 😢 )<br />
{: .prompt-tip }

## 🎊 Item 31 결론
1. `null`/`undefined`가 혼용되는 값을 만들지 않도록 노력하기
2. 만약 `null`/`undefined`가 필연적으로 들어간다면 부분적으로 보다는 전체가 존재하느냐 아니냐로 구성하기
3. 클래스를 만들 때는 필요한 값을 모두 생성한 채로 인스턴스를 만들기
4. `strictNullChecks`는 그냥 필수로 켜두기

# 📌 Item 32 ( 유니온의 인터페이스보다는 인터페이스의 유니온 사용하기 )
`Item 32`의 예시에는 아래 6가지 타입이 있다고 가정하고 설명하겠습니다.<br />

```ts
type FillLayout = {};
type LineLayout = {};
type PointLayout = {};

type FillPaint = {};
type LinePaint = {};
type PointPaint = {};
```

## 0️⃣ 유니온의 인터페이스
저희가 원하는 조합은 `FillLayout`과 `FillPaint`같은 정해진 조합이 있는데 아래처럼 작성하면 조합이 마구잡이로 섞여도 `typescript`에서 아무런 조치를 취하지 않습니다.<br />

```ts
// (1) 안 좋은 방법 ( 유니온의 인터페이스 ( 아무렇게나 조합됨 ) )
type BadLayer = {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
};
```

## 1️⃣ 인터페이스의 유니온
위 방법을 해결하기 위한 방법입니다.<br />
코드는 길어졌지만, 원하는 대로 명확하게 동작하기 때문에 더 좋은 코드입니다.<br />

```ts
// (2) 타입 분리
type FillLayer = {
  layout: FillLayer;
  paint: FillPaint;
};
type LineLayer = {
  layout: LineLayer;
  paint: LinePaint;
};
type PointLayer = {
  layout: PointLayer;
  paint: PointPaint;
};

// (3) 좋은 방법 ( 인터페이스의 유니온 )
type GoodLayer = FillLayer | LineLayer | PointLayer;
```

## 2️⃣ 태그된 유니온과 조합
인터페이스의 유니온과 태그된 유니온 방법을 사용해서 명확하게 타입을 좁혀서 사용할 수 있습니다.<br />

```ts
// (4) 타입 분리
type FillLayer = {
  type: "fill";
  layout: FillLayer;
  paint: FillPaint;
};
type LineLayer = {
  type: "line";
  layout: LineLayer;
  paint: LinePaint;
};
type PointLayer = {
  type: "point";
  layout: PointLayer;
  paint: PointPaint;
};

// (5) 좋은 방법 ( 인터페이스의 유니온 )
type TaggedLayer = FillLayer | LineLayer | PointLayer;

// (6) 태그된 유니온을 이용한 타입 좁히기
const drawLayer = (layer: TaggedLayer) => {
  switch (layer.type) {
    case "fill":
      // "FillLayer" 타입 확정
      break;
    case "line":
      // "LineLayer" 타입 확정
      break;
    case "point":
      // "PointLayer" 타입 확정
      break;
  }
};
```

### 3️⃣ 특정 속성 분리
만약 어떤 값들이 동시에 존재하거나 존재하지 않아야 하는 경우에는 하나의 객체로 묶어서 작성하는 것이 좋습니다.<br />

```ts
// (7) "HP"와 "MP"가 동시에 존재해야 한다고 가정

type BadChampion = {
  name: string;
  // (8) 각자가 독립적임
  HP?: number;
  MP?: number;
};

type GoodChampion = {
  name: string;
  // (9) 각자가 의존적
  stat: { HP?: number; MP?: number };
};
```

## 🎊 Item 32 결론
1. 유니온의 인터페이스 보다는 인터페이스의 유니온 사용하기
2. 제어 흐름을 위한 태그된 유니온 패턴은 가능하다면 활용하기

# 📌 Item 33 ( string 타입보다 더 구체적인 타입 사용하기 )
타입에는 최대한 구체적인(좁은) 타입을 사용하는 것이 좋습니다.<br />

아래와 같은 타입이 있을 때는 `releaseData`와 `recordingType`는 더 구체적인 타입으로 정할 수 있습니다.<br />

```ts
type Album = {
  artist: string;
  title: string;
  releaseData: string;
  recordingType: string;
};
```

## 0️⃣ 구체적인 타입
아래와 같이 사용하면 더 구체적인 타입을 타입체커에게 전달할 수 있습니다.<br />

```ts
/** (1) 녹음 환경 */
type RecordingType = "sudio" | "live";

type Album = {
  artist: string;
  title: string;
  releaseData: Date;
  recordingType: RecordingType;
};
```

1. `RecordingType`의 분리로 인해 다른 곳에서 활용 가능
2. 분리된 타입에 주석으로 설명 가능 `(1)`
3. `keyof`를 이용한 세밀한 속성 체크 가능

## 1️⃣ 함수의 매개변수 타입 제대로 지정하기
아래 예시는 매개변수 타입을 구체적으로 지정하는 방법에 대한 코드입니다.<br />

교재를 읽기 전에는 `(1)`처럼 코드를 구성하고 `(3)`의 결과를 보고 어떻게 수정해야 하는지 모르고 넘어갔을 것 같습니다.<br />
왜 `(1)`과 `(2)`는 다른 타입을 추론하는지 알아보겠습니다.<br />

`(1)`의 두 번째 인자는 `keyof T`의 타입을 갖습니다.<br />
따라서 `T`의 `key`중에 어떤 것도 가능하기 때문에 타입 체커는 `T[key]`로 만들 수 있는 모든 타입에 대한 배열로 추론합니다.<br />
하지만 `(2)`는 `T`의 `key`중에 하나의 타입을 제네릭으로 정했기 때문에 `T`의 특정 `key`에 해당하는 타입에 대한 배열로 추론합니다.<br />

따라서 더 구체적인 타입으로 추론하게 됩니다.<br />
( 근데 왜 `(1)`에서 `RecordingType`는 빠지는지 의문이네요.. )<br />

```ts
const pluck1 = (records: any[], key: string) => {
  return records.map((r) => r[key]);
};

const pluck2 = <T>(records: T[], key: string) => {
  return records.map((r) => r[key]);
};

// (1) <T>(records: T[], key: keyof T) => T[keyof T][]
const pluck3 = <T>(records: T[], key: keyof T) => {
  return records.map((r) => r[key]);
};

// (2) <T, K extends keyof T>(records: T[], key: K) => T[K][]
const pluck4 = <T, K extends keyof T>(records: T[], key: K) => {
  return records.map((r) => r[key]);
};

declare const albums: Album[];

// any[]
const releaseDatas1 = pluck1(albums, "releaseData");

// any[]
const releaseDatas2 = pluck2(albums, "releaseData");

// (3) (string | Date)[]
const releaseDatas3 = pluck3(albums, "releaseData");

// (4) Date[]
const releaseDatas4 = pluck4(albums, "releaseData");

// ======
// (3) (string | Date)[]
const recordingType3 = pluck3(albums, "recordingType");
// (4) RecordingType[]
const recordingType4 = pluck4(albums, "recordingType");
```

## 2️⃣ 배열과 keyof의 타입 추론
`string`이나 `number`에 포함되는 타입이 있는 경우 덮어쓰고, 그게 아니면 구체적인 타입으로 지정됩니다.<br />
그리고 `(5)`의 경우는 구체적인 타입(`Gender`, `FootSize`)이 있는데 왜 `(6)`처럼 추론을 안 하고 분리돼서 추론하는지 의문이네요...<br />
( 바로 윗부분 공부하다가 타입 추론이 생각과 다르길래 테스트해보고 의문인 부분을 기록하는 용도로 작성함 )<br />

```ts
type Gender = "T" | "F";
type FootSize = 250 | 255 | 260 | 265 | 270 | 275 | 280;

type Person1 = {
  name: string;
  age: number;
  gender: Gender;
  footSize: FootSize;
};
type Person2 = {
  // name: string;
  age: number;
  gender: Gender;
  footSize: FootSize;
};
type Person3 = {
  name: string;
  // age: number;
  gender: Gender;
  footSize: FootSize;
};
type Person4 = {
  // name: string;
  // age: number;
  gender: Gender;
  footSize: FootSize;
};

// number | string
type MyType1 = Person1[keyof Person1];
// (5) number | "T" | "F"
type MyType2 = Person2[keyof Person2];
// (5) string | 250 | 255 | 260 | 265 | 270 | 275 | 280
type MyType3 = Person3[keyof Person3];
// (6) Gender | FootSize
type MyType4 = Person4[keyof Person4];
```

## 🎊 Item 33 결론
1. `string`보다는 더 구체적인 타입 지정 ( 문자열 리터럴에 유니온으로 타입 생성 )
2. 객체의 속성 이름을 매개변수로 받는 경우 `keyof T` 혹은 템플릿으로 `K extends keyof T`와 같은 형식을 사용하면 더 구체적인 타입으로 추론됨

# 📮 레퍼런스
1. « 이펙티브 타입스크립트 4장 » ( 댄 밴더캄 지음, 장원호 옮김, 인사이트, 2021 )
2. [1-blue - 이펙티브 타입스크립트 3장( 태그된 유니온 )](/posts/이펙티브-타입스크립트-3장/#2%EF%B8%8F⃣-태그구별된-유니온){:target="_blank"}
3. [1-blue - JSDoc](/posts/JSDoc/){:target="_blank"}