---
layout: post
title: 이펙티브 타입스크립트 4장 ( Item 28 ~ 30 )
author: admin
date: 2023-01-30 08:34:00 +900
lastmod: 2023-02-03 19:30:00 +900
sitemap:
  changefreq: monthly
  priority: 0.5
categories: [Study, 이펙티브 타입스크립트]
tags: [이펙티브 타입스크립트]
image:
  path: https://insightbookblog.files.wordpress.com/2021/06/ec9db4ed8e99ed8bb0ebb88c-ed8380ec9e85ec8aa4ed81aceba6bded8ab8-ec9e85ecb2b4ed919ceca780.jpg?w=640
  width: 400
  height: 250
  alt: 이펙티브 타입스크립트 교재 이미지
---

> 해당 포스트는 `이펙티브 타입스크립트` 4장을 읽고 정리한 포스트입니다.<br />책의 모든 내용을 작성하는 것이 아닌 주관적인 기준에 따라 필요한 정보만 정리했습니다.<br />
{: .prompt-info}

📖 4장 타입 설계

# 📌 Item 28 ( 유효한 상태만 표현하는 타입을 지향하기 )

## 0️⃣ 유효한 상태와 무효한 상태를 같이 처리하는 타입
웹 애플리케이션을 만든다고 가정하고 아래 타입은 웹 애플리케이션의 페이지 로딩에 대한 타입입니다.<br />

```ts
// (1)
type State = {
  pageText: string;
  isLoading: boolean;
  error: string;
};

const changePage = async (state: State, newPage: string) => {
  state.isLoading = true;

  try {
    const response = await fetch(newPage);

    if (!response.ok) {
      throw new Error("failed fetch");
    }

    const text = await response.text();
    state.pageText = text;
  } catch (error) {
    state.error = "" + error;
  } finally {
    state.isLoading = false;
  }
};
```

`(1)`의 타입은 몇 가지 문제점이 있습니다.<br />
1. `error`가 발생한 이후 다음 실행부터는 페이지 로딩 시 에러를 보여줌 ( 즉, `error` 초기화 로직 없음 )
2. 페이지를 이동하던 중에 다른 페이지로 이동하면 결과가 이상할 수 있음

## 1️⃣ 유효한 상태와 무효한 상태를 나눠서 처리하는 타입
[태그된 유니온](/posts/이펙티브-타입스크립트-3장/#2%EF%B8%8F⃣-태그구별된-유니온){:target="_blank"}을 이용하면 상태에 맞는 값을 명시적으로 가질 수 있습니다.<br />
이전 예시는 로딩중에도 에러나 성공의 값을 가질 수 있는 반면 태그된 유니온을 사용하면 로딩중에만 갖는 값, 성공에만 갖는 값, 실패에만 갖는 값을 명확하게 나눌 수 있습니다.<br />

```ts
type RequestPending = {
  state: "pending";
};
type RequestSuccess = {
  state: "success";
  pageText: string;
};
type RequestFailure = {
  state: "failure";
  error: string;
};
type RequestState = RequestPending | RequestSuccess | RequestFailure;
type State = {
  currentPage: string;
  request: { [page: string]: RequestState };
};

const chagePage = async (state: State, newPage: string) => {
  state.currentPage = newPage;
  state.request[newPage] = { state: "pending" };

  try {
    const response = await fetch(newPage);

    if (!response.ok) {
      throw new Error("failed fetch");
    }

    const pageText = await response.text();
    state.request[newPage] = { state: "success", pageText };
  } catch (error) {
    state.request[newPage] = { state: "failure", error: "" + error };
  }
};
```

만약 사용자가 페이지 로딩중에 다른 페이지로 이동하더라도 `state.currentPage`가 마지막으로 이동한 페이지의 값을 가리키기 때문에 어떤 페이지가 렌더링될지에 대한 모호함도 없습니다.<br />

## 🎊 Item 28 결론
1. 유효한 상태와 무효한 상태를 둘 다 표현하는 타입 지양하기 ( 코드는 짧을 수 있으나 혼란을 초래할 가능성이 높음 )
2. 유요한 상태와 무효한 상태에 대한 타입을 나눠서 작성하기 ( 코드가 길어도 명확한 코드 )

# 📌 Item 29 ( 사용할 때는 너그럽게, 생성할 때는 엄격하게 )
카메라 위치를 지정하고 경계 박스의 뷰포트를 계산하는 방법에 대한 코드 예시입니다.<br />
( 교재의 예시를 그대로 가져와 사용했습니다. )<br />

## 0️⃣ 매개변수의 타입은 넓게, 반환 타입도 넓게
대부분의 타입을 옵셔널로 만들어서 유연하게 동작하도록 만들었습니다.<br />

```ts
declare function calculateBoundingBox(
  f: Feature
): [number, number, number, number];
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
declare function setCamera(camera: CameraOptions): void;

type Feature = any;
type CameraOptions = {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
};
type LngLat =
  | { lng: number; lat: number }
  | { lon: number; lat: number }
  | [number, number];
type LngLatBounds =
  | { northeast: LngLat; southwest: LngLat }
  | [LngLat, LngLat]
  | [number, number, number, number];

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  // (1) Error: 'LngLat | undefined' 형식에 'lat' 속성이 없습니다.
  const { center: { lat, lng }, zoom } = camera;
  zoom; // number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

반환 타입도 유연하게 선언해줬기 때문에 `(1)`에서 타입을 확정지을 수 없게 됩니다.<br />

코드가 조금 길어지고 복잡해보일 수 있어도 엄격한 타입과 유연한 타입을 만드는 것이 좋습니다.<br />
( 매개변수를 위한 타입 / 반환 값을 위한 타입 )<br />

## 1️⃣ 매개변수의 타입은 넓게, 반환 타입은 좁게
가능하다면 제목처럼 매개변수의 타입은 알아서, 반환 타입은 좁게하는 것이 좋습니다.<br />
반환 타입을 넓게 잡아버리면 `(1)`과 같은 문제가 발생해서 받는 쪽에서 분기를 나눠서 타입이 어떤지 구분해야 하는 불편함이 발생합니다.<br />

```ts
declare function calculateBoundingBox(
  f: Feature
): [number, number, number, number];
// (3)
declare function viewportForBounds(bounds: LngLatBounds): Camera;
declare function setCamera(camera: CameraOptions): void;

type Feature = any;
// (2)
type LngLat = { lng: number; lat: number }
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

// (2)
type Camera = { center: LngLat; zoom: number; bearing: number; pitch: number }
type CameraOptions = Omit<Partial<Camera>, "center"> & {
  center?: LngLatLike;
};
type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  // (4)
  const { center: { lat, lng }, zoom } = camera;
  zoom; // number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

`(2)`에서 기본 타입을 만들고 가능하다면 유틸리티를 사용하고 아니라면 직접적으로 옵셔널 타입을 따로 만들었습니다.<br />
타입의 정의가 늘어나는 단점이 있지만 타입은 읽기 어렵지 않기 때문에 타입이 늘어나는 것은 크게 문제가 되지 않습니다.<br />

`(3)`에서는 확실한 타입을 리턴하게 해서 `(4)`에서 받아서 그대로 사용할 수 있게 됩니다.<br />

## 🎊 Item 29 결론
1. 매개변수 타입은 넓게, 반환 타입은 좁게
2. 매개변수와 반환 타입을 위해 기본 타입을 만들고 가공해서 유연한 타입을 만드는 것이 좋음 ( 위 예시 `(2)` )

# 📌 Item 30 ( 문서에 타입 정보를 쓰지 않기 )
## 0️⃣ 주석으로 타입에 대한 설명 쓰지 않기
아래 코드는 함수에 대한 내용을 주석을 이용해서 설명한 코드입니다.<br />

```ts
/**
 * (1) 배경색을 문자열로 반환
 * (2) 0 | 1개의 매개변수를 받음
 * (3) 매개변수가 없으면 표준 배경색을 반환
 * (4) 매개변수가 있으면 특정 페이지의 배경색을 반환
 */
const getBackground = (page?: string) => page === "login" ? { r: 100, g: 100, b: 100 } : { r: 0, g: 0, b: 0 };
```

+ 문제점
  1. 잘못된 내용
  2. 필요 없는 내용

`(1)`, `(2)` 같은 내용은 함수 시그니처를 통해서 충분히 해석할 수 있는 내용인데도 주석으로 설명을 붙였습니다.<br />
지금은 상관 없을 수 있으나 만약 `getBackground()`가 수정될 경우 주석을 수동으로 바꿔주는 행동을 잊을 수 있습니다.<br />
그렇기 때문에 코드로 충분히 해석 가능한 내용을 주석으로 작성할 필요는 없습니다.<br />

`(3)`, `(4)` 또한 코드로 충분히 해석이 가능하기 때문에 주석을 작성하는 것은 좋지 않습니다.<br />
혹시 함수, 매개변수, 리턴 값에 대한 설명이 필요하다면 [JSDoc](/posts/JSDoc/){:target="_blank"}을 이용하는 것이 좋습니다.<br />

## 1️⃣ 변수명 규칙
변수명에는 정해진 규칙이 있습니다.<br />
여기서는 그런 정해진 규칙외에 사람과 사람의 소통을 위한 규칙을 설명하고자 합니다.<br />

```ts
// (5)
const ageNum = 10;

// (6)
const timeMs = 1_000;
const temperatureC = 36.5;
```

`(5)`처럼 변수의 타입에 대한 내용을 변수명으로 붙이는 방법은 좋지 않습니다.<br />
( `typescript`라서 명확하게 어떤 타입인지 확인할 수 있기 때문이죠. )<br />

`(6)`처럼 단위같이 작성하지 않으면 확실하게 알 수 없는 것은 붙이면 좋습니다.<br />
( `time`이라고하면 작성된 값을 보고 `ms`라고 추측을 하겠지만, 명확하지 않습니다. )<br />

## 🎊 Item 30 결론
1. 주석과 변수명에 타입 정보를 넣지 않기 ( 모순이 발생할 수 있음 )
2. 타입이 명확하지 않다면 변수명에 단위 정보를 포함하는 것은 좋음

# 📮 레퍼런스
1. « 이펙티브 타입스크립트 4장 » ( 댄 밴더캄 지음, 장원호 옮김, 인사이트, 2021 )
2. [1-blue - 이펙티브 타입스크립트 3장( 태그된 유니온 )](/posts/이펙티브-타입스크립트-3장/#2%EF%B8%8F⃣-태그구별된-유니온){:target="_blank"}
